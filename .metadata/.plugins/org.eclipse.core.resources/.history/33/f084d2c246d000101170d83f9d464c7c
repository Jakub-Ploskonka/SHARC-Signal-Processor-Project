/*********************************************************************************

 Copyright(c) 2012 Analog Devices, Inc. All Rights Reserved.

 This software is proprietary and confidential.  By using this software you agree
 to the terms of the associated Analog Devices License Agreement.

 *********************************************************************************/
/*
 * NAME:     blockProcess_audio.c (Block-based Talk-through)
 * PURPOSE:  Process incoming AD1939 ADC data and prepare outgoing blocks for DAC.
 * USAGE:    This file contains the subroutines that float and fix the serial data,
 *        	 and copy from the inputs to the outputs.
 */

#include "ADDS_21479_EzKit.h"
#include <fract.h>


#define TAPS	48

/*
 * np. 	float: -0.00187140162770069
 * 		fract32: -0.00187140162770069 * 2147483647 ≈ -4016400
 *
 */

fract32 pm fcoeffs[TAPS] =
{
    304183, -4018804, -9128036, -16394870, -23685927, -28142781, -26786173, -17798196,
    -1786709, 17582935, 34079285, 40651519, 32055785, 7522111, -27614702, -62194175,
    -81719022, -72565290, -26686551, 54761568, 160303227, 270154224, 361046891, 412479549,
    412479549, 361046891, 270154224, 160303227, 54761568, -26686551, -72565290, -81719022,
    -62194175, -27614702, 7522111, 32055785, 40651519, 34079285, 17582935, -1786709,
    -17798196, -26786173, -28142781, -23685927, -16394870, -9128036, -4018804, 304183
};
fract32 dm state[TAPS + 1]; //+2byczq

extern fract32 filterFIR_fract_1sample(fract32 *state, const fract32 *coeff, fract32 sample);

// ----------------------------------------------------------
//   FIR BLOCK VERSION – pętla C wołająca ASM dla 1 próbki
// ----------------------------------------------------------
void fir_block_fract(fract32 *state, const fract32 *coeff, const fract32 *x, fract32 *y,int N)
{
    for (int n = 0; n < N; n++)
    {
        y[n] = filterFIR_fract_1sample(state, coeff, x[n]);
    }
}


/* Define a structure to represent buffers for all 12 floating-point
 * data channels of the AD1939 */
typedef struct{
	float Rx_L1[NUM_SAMPLES];
	float Rx_R1[NUM_SAMPLES];
	float Rx_L2[NUM_SAMPLES];
	float Rx_R2[NUM_SAMPLES];

	float Tx_L1[NUM_SAMPLES];
	float Tx_R1[NUM_SAMPLES];
	float Tx_L2[NUM_SAMPLES];
	float Tx_R2[NUM_SAMPLES];
	float Tx_L3[NUM_SAMPLES];
	float Tx_R3[NUM_SAMPLES];
	float Tx_L4[NUM_SAMPLES];
	float Tx_R4[NUM_SAMPLES];
	
} ad1939_float_data;

/* SPORT Ping/Pong Data buffers */
extern int RxBlock_A0[];
extern int RxBlock_A1[];

extern int TxBlock_A0[];
extern int TxBlock_A1[];

extern int TxBlock_B0[];
extern int TxBlock_B1[];


/* Pointer to the blocks */
int *rxA_block_pointer[2] = {RxBlock_A0, RxBlock_A1};
int *txA_block_pointer[2] = {TxBlock_A0, TxBlock_A1};
int *txB_block_pointer[2] = {TxBlock_B0, TxBlock_B1};

/*
 * This function handles the Codec data in the following 3 steps...
 *    1. Converts all ADC data to 32-bit floating-point, and copies this
 *       from the current RX DMA buffer into fBlockA & fBlockB
 *    2. Calls the audio processing function (processBlocks)
 *    3. Converts all DAC to 1.31 fixed point, and copies this from
 *       fBlockA & fBlockB into the current TX DMA buffer
 */

void handleCodecData(unsigned int blockIndex)
{
    /* Clear the Block Ready Semaphore */
    inputReady = 0;

    /* Set the Processing Active Semaphore before starting processing */
    isProcessing = 1;

    /* Interpretujemy bufory Rx/Tx jako fract32 (1.31) */
    fract32 *rx  = (fract32*)rxA_block_pointer[blockIndex];
    fract32 *txA = (fract32*)txA_block_pointer[blockIndex];
    fract32 *txB = (fract32*)txB_block_pointer[blockIndex];

    /*
     * Układ slotów (jak w oryginalnym demie):
     *  dla każdej próbki n:
     *    rx[n * NUM_RX_SLOTS + 0] = AIN1 L
     *    rx[n * NUM_RX_SLOTS + 1] = AIN1 R
     *    rx[n * NUM_RX_SLOTS + 2] = AIN2 L
     *    rx[n * NUM_RX_SLOTS + 3] = AIN2 R
     *
     * My filtrujemy:
     *    AIN2 L  (slot 2) → AOUT1 L (slot 0)
     *    AIN2 R  (slot 3) → AOUT1 R (slot 1) [czysty przelot]
     */

    for (int n = 0; n < NUM_SAMPLES; n++)
    {
        /* Wejście do filtra: lewy kanał z wejścia 2 (AIN2 L, slot 2) */
        fract32 inL2  = rx[n * NUM_RX_SLOTS + 2];

        /* Jedna próbka filtra FIR w asemblerze */
        fract32 outL1 = filterFIR_fract_1sample(state, fcoeffs, inL2);

        /* Wyjście filtra → AOUT1 L (slot 0) */
        txA[n * NUM_TX_SLOTS + 0] = outL1;

        /* Prawy kanał: AIN2 R (slot 3) → AOUT1 R (slot 1) – czysty talkthrough */
        txA[n * NUM_TX_SLOTS + 1] = rx[n * NUM_RX_SLOTS + 3];

        /* Opcjonalnie: pozostałe wyjścia można wyzerować lub coś tam wstawić.
         * Tutaj zerujemy, żeby nie wysyłać śmieci:
         */
        txA[n * NUM_TX_SLOTS + 2] = 0;  /* AOUT2 L */
        txA[n * NUM_TX_SLOTS + 3] = 0;  /* AOUT2 R */

        txB[n * NUM_TX_SLOTS + 0] = 0;  /* AOUT3 L */
        txB[n * NUM_TX_SLOTS + 1] = 0;  /* AOUT3 R */
        txB[n * NUM_TX_SLOTS + 2] = 0;  /* AOUT4 L */
        txB[n * NUM_TX_SLOTS + 3] = 0;  /* AOUT4 R */
    }

    /* Clear the Processing Active Semaphore after processing is complete */
    isProcessing = 0;
}
