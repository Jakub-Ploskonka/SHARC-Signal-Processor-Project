/*********************************************************************************

 Copyright(c) 2012 Analog Devices, Inc. All Rights Reserved.

 This software is proprietary and confidential.  By using this software you agree
 to the terms of the associated Analog Devices License Agreement.

 *********************************************************************************/
/*
 * NAME:     blockProcess_audio.c (Block-based Talk-through)
 * PURPOSE:  Process incoming AD1939 ADC data and prepare outgoing blocks for DAC.
 * USAGE:    This file contains the subroutines that float and fix the serial data,
 *        	 and copy from the inputs to the outputs.
 */

#include "ADDS_21479_EzKit.h"
#include <fract.h>


#define TAPS	48

/*
 * np. 	float: -0.00187140162770069
 * 		fract32: -0.00187140162770069 * 2147483647 ≈ -4016400
 *
 */

fract32 pm fcoeffs[TAPS] =
{
    304183, -4018804, -9128036, -16394870, -23685927, -28142781, -26786173, -17798196,
    -1786709, 17582935, 34079285, 40651519, 32055785, 7522111, -27614702, -62194175,
    -81719022, -72565290, -26686551, 54761568, 160303227, 270154224, 361046891, 412479549,
    412479549, 361046891, 270154224, 160303227, 54761568, -26686551, -72565290, -81719022,
    -62194175, -27614702, 7522111, 32055785, 40651519, 34079285, 17582935, -1786709,
    -17798196, -26786173, -28142781, -23685927, -16394870, -9128036, -4018804, 304183
};

/* osobny stan dla lewego i prawego kanału */
fract32 dm stateL[TAPS + 1];
fract32 dm stateR[TAPS + 1];

extern fract32 filterFIR_L(fract32 *dummy_state, const fract32 *coeff, fract32 sample);
extern fract32 filterFIR_R(fract32 *dummy_state, const fract32 *coeff, fract32 sample);
// ----------------------------------------------------------
//   FIR BLOCK VERSION – pętla C wołająca ASM dla 1 próbki
// ----------------------------------------------------------
void fir_block_fract(fract32 *state, const fract32 *coeff, const fract32 *x, fract32 *y,int N)
{
    for (int n = 0; n < N; n++)
    {
        y[n] = filterFIR(state, coeff, x[n]);
    }
}

/* Define a structure to represent buffers for all 12 floating-point
 * data channels of the AD1939 */
typedef struct{
	float Rx_L1[NUM_SAMPLES];
	float Rx_R1[NUM_SAMPLES];
	float Rx_L2[NUM_SAMPLES];
	float Rx_R2[NUM_SAMPLES];

	float Tx_L1[NUM_SAMPLES];
	float Tx_R1[NUM_SAMPLES];
	float Tx_L2[NUM_SAMPLES];
	float Tx_R2[NUM_SAMPLES];
	float Tx_L3[NUM_SAMPLES];
	float Tx_R3[NUM_SAMPLES];
	float Tx_L4[NUM_SAMPLES];
	float Tx_R4[NUM_SAMPLES];
	
} ad1939_float_data;

/* SPORT Ping/Pong Data buffers */
extern int RxBlock_A0[];
extern int RxBlock_A1[];

extern int TxBlock_A0[];
extern int TxBlock_A1[];

extern int TxBlock_B0[];
extern int TxBlock_B1[];


/* Pointer to the blocks */
int *rxA_block_pointer[2] = {RxBlock_A0, RxBlock_A1};
int *txA_block_pointer[2] = {TxBlock_A0, TxBlock_A1};
int *txB_block_pointer[2] = {TxBlock_B0, TxBlock_B1};

/*
 * This function handles the Codec data in the following 3 steps...
 *    1. Converts all ADC data to 32-bit floating-point, and copies this
 *       from the current RX DMA buffer into fBlockA & fBlockB
 *    2. Calls the audio processing function (processBlocks)
 *    3. Converts all DAC to 1.31 fixed point, and copies this from
 *       fBlockA & fBlockB into the current TX DMA buffer
 */

void handleCodecData(unsigned int blockIndex)
{
    /* Clear the Block Ready Semaphore */
    inputReady = 0;

    /* Set the Processing Active Semaphore before starting processing */
    isProcessing = 1;

    /* Interpretujemy bufory Rx/Tx jako fract32 (1.31) */
    fract32 *rx  = (fract32*)rxA_block_pointer[blockIndex];
    fract32 *txA = (fract32*)txA_block_pointer[blockIndex];
    fract32 *txB = (fract32*)txB_block_pointer[blockIndex];

    // Wejścia do filtra:
        // L2 = slot 2, R2 = slot 3
        fract32 inL2[NUM_SAMPLES];
        fract32 inR2[NUM_SAMPLES];

        // Wyjścia filtra (L3,R3) – zapiszemy w txB
        fract32 outL3[NUM_SAMPLES];
        fract32 outR3[NUM_SAMPLES];

    /*
     * Układ slotów (jak w oryginalnym demie):
     *  dla każdej próbki n:
     *    rx[n * NUM_RX_SLOTS + 0] = AIN1 L
     *    rx[n * NUM_RX_SLOTS + 1] = AIN1 R
     *    rx[n * NUM_RX_SLOTS + 2] = AIN2 L
     *    rx[n * NUM_RX_SLOTS + 3] = AIN2 R
     *
     * My filtrujemy:
     *    AIN2 L  (slot 2) → AOUT1 L (slot 0)
     *    AIN2 R  (slot 3) → AOUT1 R (slot 1) [czysty przelot]
     */

        //Rozplecenie wejść blokowych na dwa kanały
            for (int n = 0; n < NUM_SAMPLES; n++)
            {
                inL2[n] = rx[n * NUM_RX_SLOTS + 2]; // AIN2 L
                inR2[n] = rx[n * NUM_RX_SLOTS + 3]; // AIN2 R
            }

            //FIR lewego kanału: L2 → L3
            fir_block_fract(stateL, fcoeffs, inL2, outL3, NUM_SAMPLES);

            //FIR prawego kanału: R2 → R3
            fir_block_fract(stateR, fcoeffs, inR2, outR3, NUM_SAMPLES);

            //Zapis wyników na wyjścia DAC3 (L3,R3) = txB slots 0,1
            for (int n = 0; n < NUM_SAMPLES; n++)
            {
                // AOUT3 L, R
                txB[n * NUM_TX_SLOTS + 0] = outL3[n]; // L3
                txB[n * NUM_TX_SLOTS + 1] = outR3[n]; // R3

                // Reszta wyjść – np. czysty przelot AIN1 -> AOUT1 (opcjonalnie)
                txA[n * NUM_TX_SLOTS + 0] = rx[n * NUM_RX_SLOTS + 0]; // L1
                txA[n * NUM_TX_SLOTS + 1] = rx[n * NUM_RX_SLOTS + 1]; // R1
                txA[n * NUM_TX_SLOTS + 2] = 0;                        // L2 out nieużyte
                txA[n * NUM_TX_SLOTS + 3] = 0;                        // R2 out nieużyte

                txB[n * NUM_TX_SLOTS + 2] = 0; // L4
                txB[n * NUM_TX_SLOTS + 3] = 0; // R4
            }

            isProcessing = 0;
}
